# Flutter App - Development Guidelines

This document outlines the architecture, patterns, and standards for developing features in this Flutter application.

**Do not re-add previously removed code.** If code was generated by an AI assistant and then removed by the developer, assume the removal was intentional. When in doubt, ask the developer before re-introducing previously removed code.

## Built with:

- **go_router** - Declarative routing with type-safe navigation
- **flutter_bloc** - BLoC pattern for state management
- **hydrated_bloc** - Persistent state management
- **freezed** - Code generation for immutable models
- **get_it + injectable** - Dependency injection
- **dio** - HTTP client for REST API calls

## Architecture Layers

The project follows a clean architecture with clear separation of concerns:

```
lib/app/
├── core/
│   ├── networking/
│   │   ├── api/           # HTTP API clients
│   │   ├── dto/           # Data Transfer Objects (only when the response json doesn't match a domain model)
│   │   ├── model/         # Domain models
│   │   └── repository/    # Data repositories
│   └── service/           # App-level services (e.g., FileCacheService)
└── feature/
    └── recipes/
        ├── bloc/          # Business logic
        ├── view/          # UI views
        └── widgets/       # Feature-specific widgets
```

## Code Standards

```dart
@freezed
abstract class Recipe with _$Recipe {
  const factory Recipe({
    required String name,
    required List<RecipeIngredient> ingredients,
    @Default(false) bool isFavorite,
  }) = _Recipe;

  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);
}
```

**Always use Freezed for data models:**

- Use `@freezed` annotation and abstract classes
- Use `@JsonSerializable(fieldRename: FieldRename.snake)` on constructor if API returns snake

### 2. BLoC Pattern

**State Management:**

```dart
@singleton
class RecipeBloc extends HydratedBloc<RecipeEvent, RecipeState> {
  RecipeBloc(this._repository) : super(const RecipeState()) {
    on<RecipeEvent>(
      (event, emit) => event.map(
        fetchRecipes: (value) => _fetchRecipes(value, emit),
        toggleFavorite: (value) => _toggleFavorite(value, emit),
      ),
    );
  }

  final RecipeRepository _repository;

  Future<void> _fetchRecipes(
    FetchRecipes event,
    Emitter<RecipeState> emit,
  ) async {
    try {
      emit(state.copyWith(loadingState: LoadingState.loading));
      final recipes = await _repository.getRecipes();
      emit(state.copyWith(
        recipes: recipes,
        loadingState: LoadingState.success,
      ));
    } catch (e) {
      emit(state.copyWith(
        loadingState: LoadingState.failure,
        errorMessage: 'Failed to fetch recipes',
      ));
      log(e.toString());
    }
  }
}
```

**Key points:**

- Use `@singleton` annotation for dependency injection
- Extend `HydratedBloc` for state persistence
- Map events using Freezed's `.map()` method
- Always wrap async operations in try-catch
- Update loading states appropriately (loading → success/failure)

**State Definition:**

```dart
@freezed
abstract class RecipeState with _$RecipeState {
  const factory RecipeState({
    @Default([]) List<Recipe> recipes,
    @Default(RecipeLoadingState.init) RecipeLoadingState loadingState,
    String? errorMessage,
  }) = _RecipeState;

  factory RecipeState.fromJson(Map<String, dynamic> json) =>
      _$RecipeStateFromJson(json);
}

enum RecipeLoadingState { init, loading, success, failure }
```

### 3. API Client Pattern

**Endpoint Definitions:**

```dart
abstract final class Endpoints {
  static const myFeature = MyFeatureRoutes._();
}

final class MyFeatureRoutes {
  const MyFeatureRoutes._();

  String get someEndpoint => '/api/path';
}
```

**API Client:**

```dart
@singleton
class MyFeatureApi {
  MyFeatureApi(this._client);

  final RestClient _client;

  Future<Response<dynamic>> getData() async {
    return _client.get(
      Endpoints.myFeature.someEndpoint,
      headers: {'Authorization': 'Bearer ${EnvironmentConfig.apiKey}'},
    );
  }
}
```

**Key points:**

- Use namespaced endpoint classes
- Inject `RestClient` for HTTP operations
- Return raw `Response<dynamic>` - let repository handle parsing
- Add authentication headers where needed

### 4. Repository Pattern

**Data Transformation:**

```dart
@singleton
class MyFeatureRepository {
  MyFeatureRepository(this._api);

  final MyFeatureApi _api;

  Future<MyModel> getData() async {
    final response = await _api.getData();
    return mapJson(response.data, MyModel.fromJson);
  }

  Future<List<MyModel>> getDataList() async {
    final response = await _api.getDataList();
    return mapJsonList(response.data, MyModel.fromJson);
  }
}
```

**Key points:**

- Use `mapJson()` for single object parsing
- Use `mapJsonList()` for array parsing
- Transform API DTOs into domain models if the json response doesn't match a domain model

### 5. View Layer

**Widgets over builder functions** - Extract reusable UI into widget classes and put them in the widgets folder, never use local builder functions or static methods that return widgets.

**BLoC Integration:**

```dart
class MyView extends StatelessWidget {
  const MyView({super.key});

  @override
  Widget build(BuildContext context) {
    final bloc = getIt<MyBloc>();

    return BlocBuilder<MyBloc, MyState>(
      bloc: bloc,
      builder: (context, state) {
        if (state.loadingState == LoadingState.loading) {
          return const Center(child: CircularProgressIndicator());
        }

        if (state.loadingState == LoadingState.failure) {
          return Center(child: Text(state.errorMessage ?? 'Error'));
        }

        return ListView.builder(
          itemCount: state.items.length,
          itemBuilder: (context, index) {
            final item = state.items[index];
            return ListTile(
              title: Text(item.name),
              onTap: () => bloc.add(MyEvent.itemTapped(item)),
            );
          },
        );
      },
    );
  }
}
```

**Key points:**

- Get bloc instances via `getIt<T>()`
- Use `BlocBuilder` for UI that depends on state
- Use `BlocSelector` for optimized rebuilds on specific state fields
- Use `BlocListener` for side effects (snackbars, navigation, etc.)
- Always handle loading, error, and success states
- prefer `BlocSelector` where possible to avoid unnecessary reloads

**Responsive Design using Layout Widget:**

This project uses a centralized `Layout` widget for responsive breakpoints:

```dart
final layout = context.layout; // Returns LayoutData

// Layout breakpoints (defined in layout.dart)

// Convenience extensions
if (context.isMobile) {
  // Mobile-specific UI
}

if (context.isTablet) {
  // Tablet-specific UI
}

if (context.isDesktop) {
  // Desktop-specific UI (large or xlarge)
}

// Comparison operators
if (context.layout >= LayoutData.medium) {
  // Show for tablet and above
}
```

**Key points:**

- Use `context.layout` to get current layout
- Use convenience getters: `context.isMobile`, `context.isTablet`, `context.isDesktop`
- Use comparison operators for range checks: `context.layout >= LayoutData.medium`
- The `Layout` widget automatically derives breakpoints from window size

### 6. Error Handling

**Always wrap async operations:**

```dart
try {
  emit(state.copyWith(loadingState: LoadingState.loading));
  final data = await _repository.getData();
  emit(state.copyWith(
    data: data,
    loadingState: LoadingState.success,
  ));
} catch (e, s) {
  emit(state.copyWith(
    loadingState: LoadingState.failure,
    errorMessage: 'User-friendly error message',
  ));
  log(e.toString());
}
```

**Show errors to users:**

```dart
BlocListener<MyBloc, MyState>(
  listenWhen: (previous, current) =>
    previous.loadingState != LoadingState.failure &&
    current.loadingState == LoadingState.failure,
  listener: (context, state) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(state.errorMessage!)),
    );
  },
  child: // ...
)
```

## AI Prompt Engineering

When working with AI for content generation:

1. **Use structured prompts** with clear sections (INPUT, OUTPUT, RULES, VALIDATION)
2. **Request JSON output** if responses are expected in JSON
3. **Include validation checklists** in the prompt
4. **Specify exact field names** and data types
5. **Provide examples** of the expected JSON structure
6. **Set appropriate temperature if possible** to modulate accuracy
7. **Use max_tokens if needed** to control response length

## Dependency Injection

This project uses `injectable` with `get_it`:

- Use `@singleton` for app-wide single instances (BLoCs, repositories, APIs)
- Access via `getIt<T>()` in views

## State Persistence

- Use `HydratedBloc` for state that should persist across app restarts
- Override `fromJson()` and `toJson()` methods
- Be selective about what to persist (e.g., don't persist loading states)

```dart
@override
Map<String, dynamic> toJson(MyState state) {
  // Only persist relevant data
  return MyState(favorites: state.favorites).toJson();
}
```

## Testing Guidelines

- Write unit tests for BLoCs (test events → state transitions)
- Test repositories with mocked API clients
- Test API clients with mocked HTTP responses
- Use Freezed's `copyWith()` for state comparisons in tests

## File Naming Conventions

- `feature_name_bloc.dart` - BLoC file
- `feature_name_view.dart` - Main view file
- `feature_name_api.dart` - API client
- `feature_name_repository.dart` - Repository
- `model_name.dart` - Model files (with .freezed.dart and .g.dart generated)

## Code Generation

**Note:** The build runner is always running in watch mode in the background during development. After modifying Freezed or Injectable code, the generated files will automatically update.

If you need to manually trigger generation:

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

## Documentation

- Add dartdoc comments (`///`) for public APIs
- Use `{@template}` and `{@macro}` for reusable documentation
- Document complex business logic
- Keep comments concise and up-to-date

### Code Comments Policy

**Do NOT add unnecessary inline comments.** Comments should only be added for:

1. **Third-party API requirements** - Explaining why certain patterns are needed for external libraries
2. **Non-obvious code** - Complex algorithms, workarounds, or business logic that isn't self-evident

**Avoid obvious comments** that simply restate what the code does:

```dart
// ❌ BAD - Obvious comment
// Remove from favorites
updatedFavorites.remove(recipe);

// ❌ BAD - Restating the code
// Get favorite recipes directly from state
final favoriteRecipes = state.favoriteRecipes;

// ✅ GOOD - Explains WHY, not WHAT
// We must use a Set here because the API can return duplicates
final uniqueRecipes = recipes.toSet().toList();
```

**Trust that clear code is self-documenting.** Use meaningful variable names and small, focused functions instead of comments.
